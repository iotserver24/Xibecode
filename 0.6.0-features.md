# XibeCode v0.6.0 Feature Preview

This release focuses on "Agentic Autonomy" and "Deep Code Understanding". We are introducing 8 major features that transform XibeCode from a coding assistant into an autonomous software engineer.

## ðŸš€ Implemented Features

### 1. Visual App Preview & Feedback Loop

**"The Agent with Eyes"**

- **Problem**: AI blindly edits CSS/HTML and hopes it looks good.
- **Solution**: Integrated Playwright browser allowing the agent to capture screenshots and "see" the DOM structure of web apps.
- **Outcome**: The agent can now verify UI changes, fix layout bugs, and validate responsive designs autonomously.
- **Tool**: `preview_app(url: string, full_page: boolean)`

**How to Test in WebUI**:

1. Start your dev server (e.g., `npm run dev`).
2. In the chat, type: `Could you preview http://localhost:3000?`
3. The agent will take a screenshot and analyze the page structure.

---

### 2. Dynamic Pattern Miner

**"The Agent that Learns You"**

- **Problem**: Every project has unique patterns (e.g., "Service classes must implement IService"). Generic AIs ignore these.
- **Solution**: A local mining engine that scans your `src/` folder, clusters similar code using AST analysis, and identifies your unique project DNA.
- **Outcome**: XibeCode writes code that looks like *you* wrote it, respecting local conventions automatically.
- **Tool**: `mine_project_patterns()`

**How to Test in WebUI**:

1. In the chat, type: `Analyze the project structure and identify coding patterns.`
2. The agent will scan `src/` files and report back with discovered code clusters and conventions.

---

### 3. Long-Running Background Agents ("Ghost Mode")

- **Capability**: Detach complex tasks (migrations, mass refactors) to background processes.
- **Benefit**: Free up your terminal while the agent works asynchronously.
- **Tech**: Node.js child processes, detached logs, PID management.

**How to Test in WebUI**:

1. In the chat, type: `Start a long-running background task: "Scan the entire codebase for TODOs and list them."`
2. The agent will spawn a separate process and provide a Task ID.
3. Check progress with `Check status of task [ID]`.

---

### 4. Semantic Code Graph

- **Capability**: A "Google Maps" for your code. Index symbols, references, and definitions suitable for AI querying.
- **Benefit**: The agent understands the "Blast Radius" of changes (e.g., "If I change this interface, these 5 files break").
- **Tech**: `ts-morph`, graph traversal.

**How to Test in WebUI**:

1. In the chat, type: `Find all references to the "User" interface.` (Replace "User" with a symbol in your project).
2. The agent will traverse the graph and list semantic usages, demonstrating deeper understanding than a simple text search.

---

### 5. AI Attribution in Git Blame

- **Capability**: Tag AI-generated commits with metadata trailers (`X-AI-Persona: Arya`).
- **Benefit**: Clear separation of human vs. synthetic code in `git blame`.
- **Tech**: Git hooks, custom blame parser, `git_commit` tool.

**How to Test in WebUI**:

1. Ask the AI to make a change: `Add a comment to src/index.ts explaining the main function.`
2. After completion, ask: `Who wrote the last change in src/index.ts?`
3. The agent will analyze `git blame` and confirm the change was made by the AI persona (e.g., "Arya").

---

### 6. Build/Plan Dual Mode

- **Capability**: Strict separation of states.
  - **PLAN**: Read-only, safe exploration.
  - **BUILD**: Write access, execution.
- **Benefit**: Prevents accidental edits during the research phase.

**How to Test in WebUI**:

1. Switch to planning mode: `[[REQUEST_MODE: plan | reason=Researching new feature]]`
2. Ask the agent to edit a file: `Add a console.log to src/index.ts.`
3. The agent will refuse because the mode is read-only.
4. Switch back to execute: `[[REQUEST_MODE: agent | reason=Applying changes]]` and ask again.

---

### 7. Intelligent Conflict Resolution

- **Capability**: A specialized agent that understands `<<<<<<< HEAD`.
- **Benefit**: Autonomously resolves merge conflicts by semantically merging "Ours" and "Theirs" rather than just picking one.

**How to Test in WebUI**:

1. (Requires a conflict) Introduce a conflict manually or ask the agent to create a conflicting file for testing.
2. If a file has conflict markers, simply ask: `Resolve the merge conflicts in [filename].`
3. The agent will parse the conflict blocks (ours/theirs) and propose a semantic merge.

---

### 8. Multi-Model Swarm

- **Capability**: Task delegation to specialized models.
  - *Planner*: Claude 3.5 Sonnet (High IQ).
  - *Worker*: Haiku / Flash (High Speed).
- **Benefit**: Faster, cheaper, and smarter execution for complex workflows.

**How to Test in WebUI**:

1. In the chat, type: `Delegate a "research" task to the "planner" agent: "Draft a high-level strategy for improving SEO."`
2. The main agent will spawn a specialized sub-agent strictly for planning.
3. Wait for the sub-agent to complete and return the strategy.
